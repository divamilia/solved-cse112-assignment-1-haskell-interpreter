Download Link: https://assignmentchef.com/product/solved-cse112-assignment-1-haskell-interpreter
<br>
For this assignment you will write Haskell interpreter for a tiny programminglanguage, let’s call it TL (Tiny Language) . The language contains just three types ofstatements:let variableName = expressionif expression goto labelprint expression1, expression2, …input variableNameEach statement may contain a preceding label. A label is an alphanumeric stringending with a colon (“:”).A number of simplifying assumptions have been made about the syntax of thelanguage.• White space (blanks) are important and must be used to separate each tokenincluding around the arithmetic operators.• There can be only one statement per line.• The expressions are limited to constant numbers, constant strings, variablenames, and binary expressions involving just one of the following operators: “+”,“-“, “*”, “/”, “&lt;“, “&gt;”, “&lt;=”, “&gt;=”, “==”, or “!=”, with their conventional meanings.Note again that the operators must be surrounded by spaces, which makes foreasier parsing.• The only types are strings and floating point numbers (Float in Haskell) andstrings are only used in print statements. The result of Boolean operations is 0 iffalse and 1 if true. Furthermore any numeric expression can be used in an ifstatementand as with the C language, 0 is false and everything else is true.• Blank lines are ignored.let variableName = expression computes the value of expression then binds that valueto the name variableName.if expression goto label computes the value of expression, if the value is 0 executioncontinues with the next statement. If the value is non-zero then execution continueswith the statement labeled label. If no such statement exists, the programterminates with the message: “tli: Illegal goto label at line x.” where x is the actualline number of the illegal goto statement.print expression1, expression2, … evaluates each expression, then prints their values,all on one line, separated by spaces, terminating the line with a newline character.input variableName attempts to read a number from the standard input. If successfulthat value is bound to the name variableName. If the read fails the program maysimply terminate with the default message: “tli: Prelude.read: no parse”.If at any point an attempt is made to evaluate an expression that references avariable variableName for which there is no binding, the program terminates withthe message: “tli: Undefined variable variableName at line x.” where x is the actualline number of the failed expression.Your program tli (tiny language interpreter) will take one command line argument,the name of the source file. It will compile the program into an internal form andthen execute the compiled program. If the input program contains any syntaxerrors, the program should exit printing a message of the form “tli: Syntax error online x.” for the first syntax error detected. Although your program is allowed tocontinue and report additional syntax errors or provide additional errorinformation, that is not required and will not affect your score.tli should make just one pass over the program source building an internalrepresentation that is a list of statements and a symbol table that maps labels intoline numbers. You may use this same symbol table to store variable bindings duringexecution of the program. Each statement should be represented by a value of anappropriately extended version of these data typesdata Expr = Constant Float | Var String | Plus Expr Expr deriving (Show)data Stmt = Let String Expr | Print Expr deriving (Show)Here is a tiny language program that prints out a sequence of numbers.input startinput endlet x = startrepeat: print xlet x = x + 1if x &lt; end goto repeatprint “done”, xAssuming the above program is stored in “prog1.txt”, when executed the command“tli prog1.txt” and the user entering 1 and 5, tli should produce the output1.02.03.04.0done 5.0You should turn in one file, tli.hs. To help you get started, I have provided the filenano.hs that parses and executes a nano-subset of the tiny language. You can findthat file in Canvas. I will spend time in class explaining nano.hs.Scoring will be done according to the following with the points in ()s.(1) parseExpr() works for all legal expressions(2) parseTest() works for all legal statement lists including labels but the SymTableproduced is incorrect(2) parseTest() works for all legal statement lists including labels with a correct andcomplete SymTable of label to linenum mappings(1) works for programs with no input and no goto(1) works for programs with no input but goto(2) works for all correct programs(1) properly reports syntax and runtime errors